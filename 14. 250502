* 클래스, 생성자의 대한 개념을 알아두기 
* 추상화 예제를 많이 접해보고 문제를 내고 풀어보기 
* 조건문, 반복문에 대한 반복적인 연습이 필요함 

수업진도 - Java/chap06/ section02 - encapsulation -- chap06/section4-2. dto

/* comment. 필드에 직접 접근하는 경우 발생할 수 있는 문제점을 이해할 수 있다. */
        /* 필드에 올바르지 않은 값이 들어가도 통제가 불가능하다. */

/* comment. 필드에 직접 접근하는 경우 발생할 수 있는 문제점을 이해할 수 있다. (2) */
        /* name -> kinds로 변경했기 때문에 직접 name 필드에 접근하는 코드는 전부 컴파일 에러를 발생시킨다.
        *  즉, Monster 클래스의 일부를 수정한 것 뿐인데, 사용하는 곳에서는 전부 함께 수정을 해야 하는 부담이 생긴 것이다.
        *  이것은 유지보수에 악영향을 미친다.
        * */

/* comment. 필드에 직접 접근하는 경우 발생할 수 있는 문제점 해결하는 방법을 이해하고 적용할 수 있다. */


/* 접근제한자
*  클래스 혹은 클래스의 멤버 참조연산자로 접근할 수 있는 범위를 제한하기 위한 키워드이다.
*  1. public : 모든 패키지에 접근 허용
*  2. protected : 동일 패키지에 접근 허용. 단, 상속관계에 있는 경우 다른 패키지에서도 접근 가능
*  3. default : 동일 패키지에서만 접근 허용. (작성하지 않는 것이 default)
*  4. private : 해당 클래스 내부에서만 접근 허용
*
*  위의 4가지 접근제한자는 클래스의 멤버(필드, 메소드)에 모두 사용 가능하다.
*  단, 클래스 선언 시 사용하는 접근제한자는 public과 default만 사용 가능하다.
* */

/* comment. 접근제한자에 대해 이해하고 직접 필드에 접근하지 못하게 강제화 할 수 있다. */

        /* 1. private 필드에 직접 접근 하여 compile error 발생 확인 */


        /* 선언한 필드대로 공간은 생성되어 있지만 직접 접근하지 못하고
        *  public으로 접근을 허용한 메소드만 이용할 수 있도록 해 놓은 것이다.
        *  이것을 캡슐화 라고 한다.
        * */

        /* 2. public 메소드를 이용하여 필드에 간접 접근 */


 /* comment. 객체지향 프로그래밍에 대해 이해하고 객체와 클래스를 설계하여 프로그래밍 할 수 있다. */

    /* 객체를 설계하기 위해서는 복잡한 현실세계를 그대로 반영하기에는 너무 방대하고 복잡하기 때문에
    *  현실 세계를 프로그램의 목적에 맞게 단순화하는 추상화라는 기법을 적용하게 된다.
    * */

    /* 추상화란?
    *  공통된 부분을 추출하고, 공통되지 않은 부분을 제거한다는 의미를 가지며, 추상화의 목적은 유연성을 확보하기 위함이다.
    *  유연성 확보는 여러 곳에 적용될 수 있는 유연한 객체를 의미하며, 즉 재사용성이 높아질 수 있게 한다는 의미이다.
    *  객체의 재사용성이 증가하면 중복 작성되는 코드를 줄일 수 있으며, 오류 발생 가능성을 감소시키고 유지보수성을 증가시킨다.
    * */

    /* 추상화 기법을 이용해서 객체를 설계하고 이를 바탕으로 클래스를 작성한 뒤 객체를 상호작용 시켜보자. */

/* 취급하려고 하는 회원정보를 고려해서 필드를 우선 작성해본다.
*  주로 화면(UI) 혹은 데이터베이스 테이블을 기준으로 한다.
*  회원번호, 회원명, 나이, 성별, .... 을 관리할 것이다.
*  객체가 가지는 속성(필드)를 추출하는 과정 또한 추상화라고 볼 수 있다.
*  DTO클래스를 만들기 위해서는 모든 필드를 private로 만든다.
* */


/* 이렇게 필드만 만들고 나면 private로 접근이 제한되었기 때문에 각 영역에 접근을 할 수 없다.
*  public으로 접근을 허용하는 설정자/접근자를 이용해 필드에 간접적으로 접근할 수 있도록 할 것이다.
* */

/* 설정자(setter)/접근자(getter)의 경우 실무에서 암묵적으로 통용되는 작성 규칙이 존재한다.
*  설정자(setter)작성 규칙
*  : 필드값을 변경할 목적의 매개변수를 변경하려는 필드와 같은 자료형으로 선언하고
*    호출 당시 전달되는 매개변수의 값을 이용하여 필드의 값을 변경한다.
*  [표현식]
*  public void set필드명(매개변수) {
*      필드 = 매개변수;
*  }
*  [작성 예시]
*  public void setName(String name) {
*      this.name = name;
*  }
*
*  접근자(getter)작성 규칙
*  : 필드의 값을 반환받을 목적의 메소드 집합을 의미한다.
*    각 접근자는 하나의 필드에만 접근하도록 한다.
*    필드에 접근해서 기록된 값을 return을 이용하여 반환하며, 이 때 반환타입은 반환하려는 값의 자료형과 일치시킨다.
*  [표현식]
*  public 반환형 get필드명() {
*      return 반환값;
*  }
*  [작성 예시]
*  public String getName() {
*     return name;
* */

/* boolean의 접근자는 get으로 시작하지 않고 is로 시작하는 것이 일반적인 관례이다. */

/* comment. 데이터를 추상화하는 기법을 이해하고 이를 사용하여 프로그래밍 할 수 있다.
    *  앞서 추상화를 이용해 객체를 설계하고 클래스를 이용해 프로그래밍을 해 보았다.
    *  하지만 추상화라는 것은 매우 어려운 작업이다.
    *
    *  캡슐화의 원칙에는 일부 어긋나긴 하지만 다른 목적을 가진 클래스와 객체를 추상화 하는 기법이 있다.
    *  행위 위주가 아닌 데이터를 하나로 뭉치기 위한 객체(Data Transfer Object)의 경우이다.
    *  이러한 객체를 설계할 때는 행위가 아닌 데이터가 위주이며, 캡슐화의 원칙을 준수하여
    *  모든 필드를 private로 직접 접근을 막고, 각 필드값을 변경하거나 반환하는 메소드를 세트로 미리 작성해둔다.
    *  어떤것을 쓸 줄 모르니 미리 다 준비해두는 종합선물세트 같은 개념이다.
    *  private 필드와 필드값을 수정하는 설정자(setter), 필드에 접근하는 접근자(getter)들로 구성된다.
    *  주로 계층간 데이터를 주고 받을 목적으로 사용한다.
    * */
- set = 수정, get = 조회
- private로 멤버필드(ex : String name, int age)를 생성하면 > set/get 메소드로 접근해야 한다.
- set 규칙 
제한자  |   리턴자     |  메소드 이름                |  인수
public  |    void     | set필드명(필드 Type 변수};  |  필수
- get 규칙 
제한자   |   리턴자    |  메소드 이름      |  인수
public  |    void     | get필드명(    };  |  필수



 /* 생성자의 작성 위치
    *  작성 위치는 문법상으로는 클래스 내부에 작성하면 되지만,
    *  통상적으로 필드 선언부와 메소드 선언부 사이에 작성하는 것이 관례이다.
    * */

    /* 생성자의 사용 목적
    *  1. 인스턴스 생성 시점에 수행할 명령이 있는 경우 사용한다.
    *  2. 매개변수 있는 생성자의 경우 매개변수로 전달받은 값으로 필드를 초기화하며 인스턴스를 생성할 목적으로 주로 사용된다.
    *  3. 작성한 생성자 외에는 인스턴스를 생성하는 방법을 제공하지 않는다는 의미를 가진다.
    *     따라서, 인스턴스를 생성하는 방법을 제한하기 위한 용도로 사용할 수도 있다. (초기값 전달 강제화)
    * */

    /* 생성자 작성 방법
    *  [표현식]
    *  접근제한자 클래스명(매개변수) {
    *       인스턴스 생성 시점에 수행할 명령 기술(주로 필드를 초기화)
    *       this.필드명 = 매개변수;        // 설정자(setter) 여러 개의 기능을 한 번의 호출로 수행할 수 있다.
    *  }
    * */

    /* 생성자 작성 시 주의할 점
    *  1. 생성자 메소드는 반드시 클래스의 이름과 동일해야 한다. (대/소문자까지 같아야함)
    *  2. 생성자 메소드는 반환형을 작성하지 않는다. (작성하는 경우 생성자가 아닌 메소드로 인식한다.)
    * */

    /* 1. 기본 생성자 */
    public User() {
        /* 수행할 내용이 아무 것도 존재하지 않는다. */
        System.out.println("User 클래스의 기본 생성자 호출함...");

    // 동일한 이름의 생성자 혹은 메소드를 한 클래스 안에서 작성하는 것은 불가능하다.


    /* 2. 매개변수 있는 생성자 */
    /* 초기화할 필드가 여러개 인 경우, 초기화 하고 싶은 필드의 갯수별로 생성자를 여러 개 준비해둘 수 있다. */
    /* id, pwd, name의 초기화를 담당할 생성자 */
    public User(String id, String pwd, String name) {
    /* 매개변수 있는 생성자의 주 목적은 인스턴스 생성 시점에 매개변수로 전달 받은 값을 이용해서 필드를 초기화한다. */

    /* 3. id, pwd, name, enrollDate의 초기화를 담당할 생성자 (모든 필드를 초기화하는 생성자) */
    public User(String id, String pwd, String name, java.util.Date enrollDate) {

        /* 매개변수로 전달 받은 값을 이용해 모든 필드를 초기화한다. */
        /* 3-1. 각 필드에 접근하여 초기화 */
        /* 3-2. 사전에 작성되어 있는 다른 생성자 함수를 이용하여 초기화 */

        /* this() : 동일 클래스 내에 작성한 다른 생성자 메소드를 호출하는 구문이다.
        *           가장 첫 줄에 선언해야 한다.
        * */
        this(id, pwd, name);    // 미리 작성한 세 개의 필드를 초기화하는 생성자로 매개변수로 받은 값을 전달


  /* comment. 생성자 함수가 무엇인지 이해하고 선언 및 호출할 수 있다. */
        /* 지금까지 우리가 객체를 생성했던 코드를 다시 한 번 살펴 볼 것이다.
        *  클래스명 레퍼런스 변수명 = new 클래스명(); 이렇게 객체를 생성했다.
        *  하지만 new 뒤에 클래스명은 사실 생성자라 불리는 메소드를 호출하는 구문이다.
        *  정확히 말하자면 클래스명 레퍼런스 변수명 = new 생성자(); 라고 표현한다.
        * */

        /* 생성자란?
        *  인스턴스를 생성할 때 초기 수행할 명령이 있는 경우 미리 작성해두고, 인스턴스를 생성할 때 호출된다.
        *  생성자 함수에 매개변수가 없는 생성자를 기본생성자(default constructor)라고 하며,
        *  기본생성자는 compiler에 의해 자동으로 추가되기 때문에 지금까지 명시적으로 작성하지 않고 사용할 수 있었다.
        *
        *  기본생성자를 이용해 인스턴스를 생성하게 되면 자바에서는 자료형별 초기값을 이용해 필드를 초기화 한다.
        *  필드의 초기값을 사용자가 원하는대로 설정하고 싶을 경우 생성자의 호출 시 인자로 값을 전달하여 호출할 수 있다.
        *  이러한 인자를 받아 필드를 초기화 할 목적의 생성자를 매개변수 있는 생성자라고 한다.
        *  하지만 매개변수 있는 생성자가 한 개라도 존재하는 경우 compiler는 기본 생성자를 자동으로 추가해주지 않는다.
        *  매개변수 있는 생성자는 주로 인스턴스 생성 시점에 필드의 값을 사용자가 원하는 대로 초기화 할 목적으로 사용한다.
        * */

        /* 1. 기본생성자 호출하여 인스턴스 생성 후 필드값 출력 */
        /* 2. id, pwd, name을 매개변수로 전달 받을 생성자를 호출하여 인스턴스 생성 후 필드 값 출력 */
        /* 3. 모든 필드를 초기화하는 생성자를 호풀하여 인스턴스 생성 후 필드값 출력 */


  /* comment. 생성자를 이용한 초기화와 설정자를 이용한 초기화의 장단점을 이해할 수 있다. */
        /* 1. 생성자를 이용한 초기화
        *  장점 : setter 메소드를 여러 번 호출해서 사용하지 않고 단 한번의 호출로 인스턴스를 생성 및 초기화 할 수 있다.
        *  단점 : 필드를 초기화할 매개변수의 갯수를 경우의 수 별로 모두 만들어둬야 한다.
        *         호출 시 인자가 많아지는 경우 어떠한 값이 어떤 필드를 의미하는지 한 눈으로 보기 힘들다.
        *
        * 2. 설정자를 이용한 초기화
        *  장점 : 필드를 초기화하는 각각의 값들이 어떤 필드를 초기화하는지 명확하게 볼 수 있다.
        *  단점 : 하나의 인스턴스를 생성할 때 한 번의 호출로 끝나지 않는다.
        * */

        /* 1. 생성자를 이용한 초기화 */
        /* 2. 기본 생성자와 설정자를 이용한 초기화 */


------------- 문제 출제 (카레이서 문제 변형) 

package org.example.abstraction250502;

import java.util.Scanner;

public class Application {
    public static void main(String[] args) {
        /* 프로그램 개요
         * 학생이 자전거를 끄는 프로그램
         *
         *  시스템 요구사항
         *  1. 학생은 자물쇠 풀기, 페달 밟기, 브레이크 밟기, 자물쇠 잠그기 할 수 있다.
         *  2. 자전거는 자물쇠 풀기 , 앞으로 가기, 멈추기, 자물쇠 잠그기 를 할 수 있다.
         *  3. 자전거 처음에 멈춘 상태로 대기하고 있는다.
         *  4. 학생은 먼저 자전거에 자물되를 푼다. 이미 자물쇠가 풀려 있는 경우 다시 잠글 필요가 없다.
         *  5. 학생이 페달을 밟으면 시동이 걸린 상태일 경우 자전거는 시속 5km/h 증가하며 앞으로 나간다.
         *  6. 자전거가 달리는 중인 경우 브레이크를 밟으면 자전거의 시속은 0으로 떨어지며 멈춘다.
         *  7. 브레이크를 밟을 때 자전거가 달리는 중이 아니라면 이미 멈춰있는 상태라고 안내한다.
         *  8. 학생이 자물쇠를 잠그면  더 이상 자전거는 움직이지 않는다.
         *  9. 자전거가 달리는 중이라면 멈출 수 없다.
         * */

        /* 프로그램 설계하기
         *  1. 필요한 객체 도출
         *  - 플레이어(사용자), 학생, 자전거
         *
         *  2. 객체간 상호작용
         *  -  학생 수신할 수 있는 메세지 (학생이 해야하는 일)
         *  1. 자물쇠 풀기
         *  2. 페달을 밟아라
         *  3. 브레이크를 밟아라
         *  4. 자물쇠를 잠거라
         *
         *  - 자전거가 수신할 수 있는 메시지 (자전거가 해야 하는 일)
         *  1. 자물쇠 풀기
         *  2. 앞으로 가라
         *  3. 멈춰라
         *  4. 자물쇠를 잠거라
         * */

        Student student = new Student();

        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println("================ 자전거 운행 프로그램 ===================");
            System.out.println("1. 자물쇠 풀기 ");
            System.out.println("2. 전진");
            System.out.println("3. 정지");
            System.out.println("4. 자물쇠 잠그기");
            System.out.println("9. 프로그램 종료");
            System.out.print("메뉴 선택 : ");
            int no = sc.nextInt();

            switch (no) {
                case 1 : student.startUp(); break;
                case 2 : student.goAccelator(); break;
                case 3 : student.stopBreak();; break;
                case 4 : student.turnOff(); break;
                case 9 :
                    System.out.println("프로그램을 종료합니다."); break;
                default:
                    System.out.println("잘못된 번호를 선택하셨습니다."); break;
            }

            if(no == 9) {
                break;
            }
        }
   }
 }

-------------

package org.example.abstraction250502;

public class Cycle {
    private boolean isOn;
    private int speed;

    public void startUp() {
        if(isOn) {
            System.out.println("이미 자물쇠가 풀려 있습니다.");
        } else {
            this.isOn = true;
            System.out.println("자물쇠를 풀었습니다. 이제 출발할 준비가 완료되었습니다.");
        }
    }

    public void go() {
        if(isOn) {
            System.out.println(" 자전거가 앞으로 움직입니다.");
            this.speed += 5;
            System.out.println("현재 차의 시속은 " + this.speed + "km/h 입니다.");
        } else {
            System.out.println(" 자전거의 자물쇠가 풀리지 않았습니다. 자물쇠를 먼저 풀어주세요.");
        }
    }

    public void stop() {
        if(isOn) {
            if(this.speed > 0) {
                this.speed = 0;
                System.out.println("브레이크를 밟았습니다. 자전거를 멈춥니다.");
            } else {
                System.out.println("자전거는 이미 멈춰있는 상태입니다.");
            }
        } else {
            System.out.println("자전거의 자물쇠가 풀리지 않았습니다. 자물쇠를 먼저 풀어주세요.");
        }
    }

    public void turnOff() {
        if(isOn) {
            if(speed > 0) {
                System.out.println("달리는 상태에서 자물쇠를 잠글 수 없습니다. 자전거를 우선 멈춰주세요.");
            } else {
                this.isOn = false;
                System.out.println("자물쇠를 잠급니다. 다시 운행하려면 자물쇠를 풀어주세요.");
            }
        } else {
            System.out.println("이미 자물쇠로 잠겨 있습니다. 잠금 상태를 확인해주세요.");
        }
    }
}

------

package org.example.abstraction250502;

public class Student {
    private final Cycle cycle = new Cycle();

    public void startUp() {
        cycle.startUp();
    }

    public void goAccelator() {
        cycle.go();
    }

    public void stopBreak() {
        cycle.stop();
    }

    public void turnOff() {
        cycle.turnOff();

    }
}

