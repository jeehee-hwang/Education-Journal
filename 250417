** 객체 = 프로퍼티 = 인스턴스 **

function(함수)

function definiton (함수 정의)
 1. function declaration(함수 선언문)
   함수 선언문에서는 함수의 이름을 생략할 수 없다.
   
 2. function expression(함수 표현식)
    함수 표현식에서는 함수명을 생략할 수 있다.

 3. function hoisting (함수 호이스팅)
  함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
  함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.

  function call(함수 호출)
   1. parameter and arguments
      매개변수는 함수 몸체 내부에서만 참조
      함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.  
        인수가 부족해서 할당되지 않은 매개변수의 값은 undefined이다.
        매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.
      매개변수의 최대 개수는 3개 이상을 넘지 않는 것을 권장한다. (함수는 한 가지 일만 하는게 좋음, 가급적 작게 만들 것)
    
   2. return
     반환문은 리턴 키워드 뒤에 오는 값을 반환
     반환 값을 명시적으로 지정하지 않으면 undefined가 반환  
     반환문을 생략할 수도 있다. 이때도 암묵적으로 undefined를 반환

  arrow function(화살표 함수)
    화살표 함수는 항상 익명 함수로 정의
    본문이 한 줄인 함수를 작성할 때 유용
        // function 키워드 생략 가능
        message = () => {    
        	return "Arrow Function!";

 various type of functions(다양한 타입의 함수)
 1. immediately invoked function expression(즉시 실행 함수)
    - 함수 정의와 동시에 즉시 호출되는 함수로 단 한 번만 호출 되며 다시 호출할 수 없다.
     (function() {    
    	console.log('익명 즉시 실행 함수! 함수 정의와 동시에 호출!');
    })();

2.  recursive function(재귀 함수)
  함수가 자기 자신을 호출하는 것을 재귀 호출
  반복되는 처리를 위해 사용
  장점 - 재귀 함수는 반복 되는 처리를 반복문 없이 구현할 수 있음 
  단점 - 무한 반복에 빠질 위험이 있고 이로 인해 스택 오버플로 에러를 발생시킬 수 있음 

3. nested function(중첩 함수)
 함수 내부에 정의 된 함수를 중첩 함수 또는 내부 함수라고 한다.
 중첩 함수를 포함하는 함수는 외부 함수라고 한다.
 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
    function outer() {    
    	var outerVal = '외부 함수';    
    function inner() {        
    	var innerVal = '내부 함수';        // 외부 함수의 변수를 참조할 수 있다.        
    	console.log(outerVal, innerVal);    
    	}    
    	inner();
    }
    outer();

4.  callback function(콜백 함수)
    함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
    매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수를 고차 함수
    콜백 함수는 고차 함수에 전달 되어 헬퍼 함수의 역할을 한다. 즉, 고차 함수는 콜백 함수를 자신의 일부분으로 합성
    함수의 변하지 않는 공통 로직은 미리 정의해두고 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달하는 방식
    // 전달 받은 값을 증가 시켜주는 함수
      function increase (value) {    
      	return value + 1;
      }
      // 전달 받은 값을 감소 시켜주는 함수
      function decrease (value) {    
      	return value - 1;
      }
      // 전달 받은 함수에 전달 받은 값을 적용 시켜주는 고차 함수
      function apply(func, value) {    
      // 고차 함수는 매개변수를 통해 전달 받을 콜백 함수의 호출 시점을 결정해서 호출한다.    
      // 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백함수에 인수를 전달할 수 있다.    
      	return func(value);
      }
      // 고차 함수로 콜백 함수를 전달하며 호출
      console.log(apply(increase, 5));
      console.log(apply(decrease, 5));
           
  5. pure and impure function(순수 함수와 비순수 함수)
     순수 함수 : 외부 상태에 의존하지도 않고 변경하지도 않는 함수
     비순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는 함수
     함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.

scope
 1. global and local scope (전역과 지역 스코프)
    - 전역은 코드의 가장 바깥 영역을 말하며 전역은 전역 스코프를 만든다.
        - 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 되며 전역 변수는 어디서든지 참조할 수 있다.
    - 지역이란 함수 몸체 내부를 말하며 지역은 지역 스코프를 만든다.
        - 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 되며 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

 2. function level scope (함수 레벨 스코프) 
    var 키워드로 선언 된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하는 함수 레벨 스코프(function level scope)를 가짐

let and const
var - 문제를 야기함 (변수 중복 선언, 함수 레벨 스코프, 변수 호이스팅) 
let - var 키워드의 단점을 보완
    - 변수 중복 선언 금지
    - 블록 레벨 스코프 - let 키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문)을 지역 스코프로 인정
    - 변수 호이스팅이 발생하기는 함 그러나 발생하지 않는 것 처럼 동작함 
    - let 키워드는 선언 단계와 초기화 단계가 분리되어 진행 따라서 선언은 되었지만 초기화가 되지 않아 참조 시 오류가 발생

const - const 키워드는 상수(constant)를 선언하기 위해 사용
      - const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야함 
      - const 키워드로 선언한 변수는 재할당이 금지

# 정리
ES6를 사용한다면 var 키워드는 사용하지 않는다. 
재할당이 필용한 경우에 한정해 let 키워드를 사용하며 변수의 스코프는 최대한 좁게 만든다. 
변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를 사용한다. 
const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전한다.

Object constructor function (객체 생성자 함수)
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환
- 빈 객체 생성 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있음 

constructor function (생성자 함수)
- 객체 리터럴을 이용한 객체 생성 방식은 직관적이고 간편하지만, 단 하나의 객체만 생성
- 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성

 inheritance (상속)
[[Prototype]]
- 자바스크립트의 객체는 [[Prototype]]이라는 숨김 프로퍼티를 갖음 이 프로퍼티 값은 null이거나 다른 객체에 대한 참조가 됨 
> 다른 객체를 참조 하는 경우 참조 대상을 프로토타입(prototype)이라고 함 
-  object에서 프로퍼티를 읽으려 할 때 해당 프로퍼티가 없으면 자바스크립트는 자동으로 프로토타입에서 프로퍼티를 찾는다.
    -> 프로토타입 상속
- __proto__ 는 [[Prototype]]의 getter, setter이다.
- 프로토타입 체이닝은 순환 참조(circle reference)가 허용되지 않는다.

prototype feature
프로토타입은 프로퍼티를 읽을 때만 사용하며 프로퍼티를 추가, 수정, 삭제하는 연산은 객체에 직접해야 함 
메소드 내의 this는 프로토 타입에 영향받지 않으며 메소드를 객체에서 호출했든 
프로토타입에서 호출했든 상관없이 this는 언제나 .앞에 있는 객체임 
메소드는 공유되지만 객체의 상태는 공유되지 않음 

